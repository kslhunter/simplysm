[{"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\index.ts":"1","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\SdProjectConfigUtils.ts":"2","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliLocalUpdate.ts":"3","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdCallMetadata.ts":"4","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdObjectMetadata.ts":"5","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdArrayMetadata.ts":"6","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdFunctionMetadata.ts":"7","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdErrorMetadata.ts":"8","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdMetadataCollector.ts":"9","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdModuleMetadata.ts":"10","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\commons.ts":"11","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdClassMetadata.ts":"12","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdNgGenerator.ts":"13","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdPackageBuilder.ts":"14","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliPackage.ts":"15","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliProject.ts":"16","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin.ts":"17","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-worker.ts":"18","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\commons.ts":"19","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdAngularUtils.ts":"20","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdWebpackWriteFilePlugin.ts":"21","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdWebpackInputHostWithScss.ts":"22","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\inline-sass-loader.ts":"23","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdTypescriptWatcher.ts":"24"},{"size":935,"mtime":1585988643770,"results":"25","hashOfConfig":"26"},{"size":1884,"mtime":1584722446927,"results":"27","hashOfConfig":"26"},{"size":4817,"mtime":1586174726188,"results":"28","hashOfConfig":"26"},{"size":1623,"mtime":1585813339213,"results":"29","hashOfConfig":"26"},{"size":1270,"mtime":1585813363309,"results":"30","hashOfConfig":"26"},{"size":985,"mtime":1583316824046,"results":"31","hashOfConfig":"26"},{"size":619,"mtime":1583316824064,"results":"32","hashOfConfig":"26"},{"size":483,"mtime":1583316824050,"results":"33","hashOfConfig":"26"},{"size":7696,"mtime":1585818180809,"results":"34","hashOfConfig":"26"},{"size":1448,"mtime":1584878893854,"results":"35","hashOfConfig":"26"},{"size":760,"mtime":1583489552015,"results":"36","hashOfConfig":"26"},{"size":2305,"mtime":1585817633865,"results":"37","hashOfConfig":"26"},{"size":38154,"mtime":1586266960191,"results":"38","hashOfConfig":"26"},{"size":40158,"mtime":1586327068328,"results":"39","hashOfConfig":"26"},{"size":12515,"mtime":1586346848122,"results":"40","hashOfConfig":"26"},{"size":19580,"mtime":1586255845145,"results":"41","hashOfConfig":"26"},{"size":6627,"mtime":1586326971844,"results":"42","hashOfConfig":"26"},{"size":1374,"mtime":1586326978808,"results":"43","hashOfConfig":"26"},{"size":1897,"mtime":1586346305784,"results":"44","hashOfConfig":"26"},{"size":1441,"mtime":1585478449871,"results":"45","hashOfConfig":"26"},{"size":1510,"mtime":1584951988483,"results":"46","hashOfConfig":"26"},{"size":1122,"mtime":1585568479742,"results":"47","hashOfConfig":"26"},{"size":1539,"mtime":1584950576938,"results":"48","hashOfConfig":"26"},{"size":15907,"mtime":1586075248011,"results":"49","hashOfConfig":"26"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"d0dw89",{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\index.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\SdProjectConfigUtils.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliLocalUpdate.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdCallMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdObjectMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdArrayMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdFunctionMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdErrorMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdMetadataCollector.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdModuleMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\commons.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\metadata\\SdClassMetadata.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdNgGenerator.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdPackageBuilder.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliPackage.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin\\SdCliProject.ts",["99"],"import {FsUtils, Logger, ProcessManager, ProcessWorkManager} from \"@simplysm/sd-core-node\";\r\nimport * as path from \"path\";\r\nimport {INpmConfig, ISdProjectConfig} from \"../commons\";\r\nimport {DateTime, NeverEntryError, Wait} from \"@simplysm/sd-core-common\";\r\nimport {SdCliPackage} from \"./SdCliPackage\";\r\nimport {ISdPackageBuildResult} from \"../build-tools/SdPackageBuilder\";\r\nimport * as os from \"os\";\r\nimport * as semver from \"semver\";\r\nimport {SdProjectConfigUtils} from \"../SdProjectConfigUtils\";\r\nimport {SdCliLocalUpdate} from \"./SdCliLocalUpdate\";\r\nimport {SdServiceServer} from \"@simplysm/sd-service-node\";\r\nimport {NextHandleFunction} from \"connect\";\r\n\r\nconst decache = require(\"decache\");\r\n\r\nexport class SdCliProject {\r\n  private readonly _servers: {\r\n    [name: string]: {\r\n      server?: SdServiceServer;\r\n      middlewares: {\r\n        [clientName: string]: NextHandleFunction[];\r\n      };\r\n    };\r\n  } = {};\r\n\r\n  public static async createAsync(argv: { devMode: boolean; packages: string[]; config?: string; options: string[] }): Promise<SdCliProject> {\r\n    const logger = Logger.get([\"simplysm\", \"sd-cli\", \"project\"]);\r\n\r\n    logger.debug(\"프로젝트 준비...\");\r\n\r\n    const configPath = argv.config !== undefined ?\r\n      path.resolve(process.cwd(), argv.config) :\r\n      path.resolve(process.cwd(), \"simplysm.json\");\r\n    const config = await SdProjectConfigUtils.loadConfigAsync(configPath, argv.devMode, argv.options);\r\n\r\n    const npmConfigPath = path.resolve(process.cwd(), \"package.json\");\r\n    const npmConfig: INpmConfig = await FsUtils.readJsonAsync(npmConfigPath);\r\n\r\n    const processManager = await ProcessWorkManager.createAsync(path.resolve(__dirname, \"../build-worker\"), [], os.cpus().length - 1);\r\n\r\n    if (!npmConfig.workspaces) throw new NeverEntryError();\r\n    const packages = (\r\n      await npmConfig.workspaces.parallelAsync(async workspace => {\r\n        const workspacePath = path.resolve(process.cwd(), workspace);\r\n        const packagePaths = await FsUtils.globAsync(workspacePath);\r\n\r\n        return await packagePaths.parallelAsync(async packagePath => {\r\n          const pkgNpmConfigPath = path.resolve(packagePath, \"package.json\");\r\n          const pkgNpmConfig = (await FsUtils.readJsonAsync(pkgNpmConfigPath)) as INpmConfig;\r\n          let pkgConfig = config.packages[pkgNpmConfig.name];\r\n\r\n          if (argv.packages.length > 0 && !argv.packages.includes(pkgNpmConfig.name)) {\r\n            // return undefined;\r\n            pkgConfig = undefined;\r\n          }\r\n\r\n          return await SdCliPackage.createAsync(processManager, packagePath, pkgNpmConfig, pkgNpmConfigPath, pkgConfig, argv.devMode);\r\n        });\r\n      })\r\n    ).mapMany().filterExists();\r\n\r\n    logger.debug(\"프로젝트 준비 완료\");\r\n\r\n    return new SdCliProject(logger, processManager, packages, config, npmConfig, npmConfigPath);\r\n  }\r\n\r\n  private constructor(private readonly _logger: Logger,\r\n                      private readonly _processManager: ProcessWorkManager,\r\n                      private readonly _packages: SdCliPackage[],\r\n                      private readonly _config: ISdProjectConfig,\r\n                      private readonly _npmConfig: INpmConfig,\r\n                      private readonly _npmConfigPath: string) {\r\n  }\r\n\r\n  public async buildAsync(watch: boolean, subBuild?: (\"gen-index\" | \"check\" | \"lint\" | \"compile\" | \"gen-ng\")[]): Promise<void> {\r\n    if (watch) {\r\n      await SdCliLocalUpdate.watchAsync(this._config);\r\n    }\r\n    else {\r\n      await SdCliLocalUpdate.runAsync(this._config);\r\n    }\r\n\r\n    this._logger.debug(`빌드 준비...`);\r\n    await this._upgradeVersionAsync(watch);\r\n    await this._packages.parallelAsync(async pkg => {\r\n      await Promise.all([\r\n        pkg.updateVersionAsync(this._npmConfig.version, this._packages.map(item => item.name)),\r\n        pkg.createTsBuildConfigAsync()\r\n      ]);\r\n      await pkg.removeDistPathAsync();\r\n    });\r\n    this._logger.debug(`빌드 준비 완료`);\r\n\r\n    this._logger.debug(`빌드 시작...`);\r\n\r\n    let isFirstCompleted = false;\r\n\r\n    await new Promise<void>(async (resolve, reject) => {\r\n      try {\r\n        const lastResultsObj: { [key: string]: ISdPackageBuildResult[] | undefined } = {};\r\n\r\n        let startTick = new DateTime().tick;\r\n        let busyCount = 0;\r\n        this._logger.debug(`busyCount: ${busyCount}`);\r\n\r\n        const endFn = (): void => {\r\n          setTimeout(\r\n            async () => {\r\n              busyCount -= 1;\r\n              this._logger.debug(`busyCount: ${busyCount}`);\r\n\r\n              if (busyCount === 0) {\r\n                const warnings = Object.values(lastResultsObj)\r\n                  .mapMany(item => item ?? [])\r\n                  .filter(item => item.severity === \"warning\")\r\n                  .map(item => item.message.trim())\r\n                  .distinct().join(os.EOL);\r\n                const errors = Object.values(lastResultsObj)\r\n                  .mapMany(item => item ?? [])\r\n                  .filter(item => item.severity === \"error\")\r\n                  .map(item => item.message.trim())\r\n                  .distinct().join(os.EOL);\r\n\r\n                if (warnings.length > 0) {\r\n                  this._logger.warn(`경고 발생${os.EOL}`, warnings);\r\n                }\r\n                if (errors.length > 0) {\r\n                  this._logger.error(`오류 발생${os.EOL}`, errors);\r\n                }\r\n\r\n                resolve();\r\n\r\n                await Wait.true(() => isFirstCompleted);\r\n                this._logger.info(`빌드 프로세스가 완료되었습니다.(${(new DateTime().tick - startTick).toLocaleString()}ms)`);\r\n              }\r\n            },\r\n            watch && isFirstCompleted ? 300 : 3000\r\n          );\r\n        };\r\n\r\n        for (const pkg of this._packages) {\r\n          pkg.on(\"change\", data => {\r\n            if (busyCount === 0) {\r\n              startTick = new DateTime().tick;\r\n              this._logger.log(`변경감지...`);\r\n            }\r\n            busyCount += 1;\r\n            this._logger.debug(`busyCount: ${busyCount}`);\r\n\r\n            if (data.filePaths) {\r\n              delete lastResultsObj[`${data.command}-${data.target ?? \"\"}-${data.packageName}`];\r\n              for (const filePath of data.filePaths) {\r\n                const key = `${data.command}-${data.target ?? \"\"}-${filePath}`;\r\n                delete lastResultsObj[key];\r\n              }\r\n            }\r\n            else {\r\n              const removeKeys = Object.keys(lastResultsObj)\r\n                .filter(key => key.startsWith(`${data.command}-${data.target ?? \"\"}-`));\r\n              for (const removeKey of removeKeys) {\r\n                delete lastResultsObj[removeKey];\r\n              }\r\n            }\r\n          });\r\n          pkg.on(\"complete\", data => {\r\n            for (const result of data.results) {\r\n              const key = `${data.command}-${data.target ?? \"\"}-${result.filePath ?? data.packageName}`;\r\n              lastResultsObj[key] = lastResultsObj[key] ?? [];\r\n              lastResultsObj[key]!.push(result);\r\n            }\r\n\r\n            endFn();\r\n          });\r\n        }\r\n\r\n        busyCount += 1;\r\n        this._logger.debug(`busyCount: ${busyCount}`);\r\n\r\n        // const genIndexCompleted: string[] = [];\r\n        // const genNgCompleted: string[] = [];\r\n        const depCheckCompleted: string[] = [];\r\n        const checkCompleted: string[] = [];\r\n\r\n        await Promise.all([\r\n          this._parallelPackagesByDepAsync(async pkg => {\r\n            depCheckCompleted.push(pkg.name);\r\n\r\n            if (!subBuild || subBuild.includes(\"check\")) {\r\n              this._logger.debug(\"check: \" + pkg.name);\r\n              await pkg.checkAsync();\r\n              this._logger.debug(\"check: \" + pkg.name + \": end\");\r\n            }\r\n\r\n            checkCompleted.push(pkg.name);\r\n          }),\r\n          this._parallelPackagesByDepAsync(async pkg => {\r\n            await Wait.true(() => depCheckCompleted.includes(pkg.name));\r\n\r\n            if (!subBuild || subBuild.includes(\"compile\")) {\r\n              if (pkg.info.config?.type === \"library\") {\r\n                await pkg.compileAsync();\r\n              }\r\n              else if (pkg.info.config?.type === \"server\") {\r\n                if (pkg.info.npmConfig.main === undefined) {\r\n                  throw new Error(\"서버빌드시, 'package.json'에 'main'이 반드시 설정되어 있어야 합니다.\");\r\n                }\r\n\r\n                if (watch) {\r\n                  await pkg\r\n                    .on(\"change\", async arg => {\r\n                      if (arg.command !== \"compile\") return;\r\n                      await this._stopServerAsync(pkg);\r\n                    })\r\n                    .on(\"complete\", async arg => {\r\n                      if (arg.command !== \"compile\") return;\r\n                      await this._startServerAsync(pkg);\r\n                    })\r\n                    .compileAsync();\r\n                }\r\n                else {\r\n                  await pkg.compileAsync();\r\n                }\r\n              }\r\n              else if (pkg.info.config?.type === \"web\") {\r\n                if (watch) {\r\n                  const middlewares = (\r\n                    await pkg\r\n                      .on(\"change\", arg => {\r\n                        if (arg.command !== \"compile\") return;\r\n                        this._logger.log(`[${pkg.name}] 클라이언트 준비...`);\r\n                      })\r\n                      .on(\"complete\", async arg => {\r\n                        if (arg.command !== \"compile\") return;\r\n                        await Wait.true(() => this._servers[pkg.info.config?.[\"server\"]].server !== undefined);\r\n                        const port = this._servers[pkg.info.config?.[\"server\"]].server!.options.port ?? 80;\r\n                        this._logger.info(`[${pkg.name}] 클라이언트가 준비되었습니다.: http://localhost:${port}/${path.basename(pkg.info.rootPath)}/`);\r\n                      })\r\n                      .compileClientAsync(true)\r\n                  ) as NextHandleFunction[];\r\n\r\n                  await this._registerClientAsync(pkg, middlewares);\r\n                }\r\n                else {\r\n                  await pkg.compileClientAsync(false);\r\n                }\r\n              }\r\n            }\r\n          }),\r\n          this._packages.parallelAsync(async pkg => {\r\n            await Wait.true(() => depCheckCompleted.includes(pkg.name));\r\n\r\n            if (!subBuild || subBuild.includes(\"lint\")) {\r\n              await pkg.lintAsync();\r\n            }\r\n          }),\r\n          this._packages.parallelAsync(async pkg => {\r\n            await Wait.true(() => checkCompleted.includes(pkg.name));\r\n\r\n            if (!subBuild || subBuild.includes(\"gen-ng\")) {\r\n              await pkg.genNgAsync();\r\n            }\r\n\r\n            // genNgCompleted.push(pkg.name);\r\n          }),\r\n          this._packages.parallelAsync(async pkg => {\r\n            await Wait.true(() => checkCompleted.includes(pkg.name));\r\n\r\n            if (!subBuild || subBuild.includes(\"gen-index\")) {\r\n              await pkg.genIndexAsync();\r\n            }\r\n\r\n            // genIndexCompleted.push(pkg.name);\r\n          })\r\n        ]);\r\n\r\n        endFn();\r\n      }\r\n      catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n\r\n    this._logger.debug(`빌드 완료`);\r\n\r\n    if (!watch) {\r\n      this._logger.debug(`프로세스 종료...`);\r\n\r\n      await this._processManager.closeAllAsync();\r\n\r\n      this._logger.debug(`프로세스 종료`);\r\n    }\r\n\r\n    isFirstCompleted = true;\r\n  }\r\n\r\n  public async compileAsync(watch: boolean): Promise<void> {\r\n    await this.buildAsync(watch, [\"check\", \"compile\"]);\r\n  }\r\n\r\n  public async lintAsync(watch: boolean): Promise<void> {\r\n    await this.buildAsync(watch, [\"check\", \"lint\"]);\r\n  }\r\n\r\n  public async genNgAsync(watch: boolean): Promise<void> {\r\n    await this.buildAsync(watch, [\"check\", \"gen-ng\"]);\r\n  }\r\n\r\n  public async publishAsync(build: boolean): Promise<void> {\r\n    // TODO: Dependency 폴더의 버전과 yarn.lock에 있는 버전이 서로 다르면 배포 불가\r\n\r\n    if (!build) {\r\n      this._logger.warn(\"빌드하지 않고, 배포하는것은 상당히 위험합니다.\");\r\n      process.stdout.write(\"프로세스를 중지하려면, 'CTRL+C'를 누르세요. 3\");\r\n      await Wait.time(1000);\r\n\r\n      process.stdout.cursorTo(0);\r\n      process.stdout.write(\"프로세스를 중지하려면, 'CTRL+C'를 누르세요. 2\");\r\n      await Wait.time(1000);\r\n\r\n      process.stdout.cursorTo(0);\r\n      process.stdout.write(\"프로세스를 중지하려면, 'CTRL+C'를 누르세요. 1\");\r\n      await Wait.time(1000);\r\n\r\n      process.stdout.cursorTo(0);\r\n      process.stdout.clearLine(0);\r\n    }\r\n\r\n    this._logger.debug(`배포 준비...`);\r\n\r\n    // GIT 사용중일 경우, 커밋되지 않은 수정사항이 있는지 확인\r\n    if (FsUtils.exists(path.resolve(process.cwd(), \".git\"))) {\r\n      await ProcessManager.spawnAsync(\r\n        \"git status\",\r\n        undefined,\r\n        message => {\r\n          if (message.includes(\"Changes\") || message.includes(\"Untracked\")) {\r\n            throw new Error(\"커밋되지 않은 정보가 있습니다.\");\r\n          }\r\n        },\r\n        false\r\n      );\r\n    }\r\n\r\n    // 빌드가 필요하면 빌드함\r\n    if (build) {\r\n      await this.buildAsync(false);\r\n    }\r\n    // watch 버전에선 배포 불가\r\n    else if (this._npmConfig.version.includes(\"-\")) {\r\n      throw new Error(\"현재 최종 버전이 빌드(배포) 버전이 아닙니다.\");\r\n    }\r\n    // 빌드시엔 빌드에서 버전업했고, 빌드가 아닌경우 여기서 버전업\r\n    else {\r\n      await this._upgradeVersionAsync(false);\r\n      await this._packages.parallelAsync(async pkg => {\r\n        await pkg.updateVersionAsync(this._npmConfig.version, this._packages.map(item => item.name));\r\n      });\r\n    }\r\n\r\n    // GIT 사용중일경우, 새 버전 커밋 및 TAG 생성\r\n    if (build && FsUtils.exists(path.resolve(process.cwd(), \".git\"))) {\r\n      await ProcessManager.spawnAsync(\r\n        `git add .`,\r\n        undefined,\r\n        false,\r\n        false\r\n      );\r\n\r\n      await ProcessManager.spawnAsync(\r\n        `git commit -m \"v${this._npmConfig.version}\"`,\r\n        undefined,\r\n        false,\r\n        false\r\n      );\r\n\r\n      await ProcessManager.spawnAsync(\r\n        `git tag -a \"v${this._npmConfig.version}\" -m \"v${this._npmConfig.version}\"`,\r\n        {},\r\n        false,\r\n        false\r\n      );\r\n    }\r\n\r\n    this._logger.debug(`배포 준비 완료`);\r\n\r\n    this._logger.debug(`배포 시작...`);\r\n\r\n    await this._packages.parallelAsync(async pkg => {\r\n      await pkg.publishAsync();\r\n    });\r\n\r\n    this._logger.debug(`프로세스 종료...`);\r\n\r\n    await this._processManager.closeAllAsync();\r\n\r\n    this._logger.debug(`프로세스 종료`);\r\n\r\n    this._logger.info(`배포 프로세스가 완료되었습니다.(v${this._npmConfig.version})`);\r\n  }\r\n\r\n  private async _upgradeVersionAsync(prerelease: boolean): Promise<void> {\r\n    const newVersion = semver.inc(this._npmConfig.version, prerelease ? \"prerelease\" : \"patch\");\r\n    if (newVersion == null) throw new NeverEntryError();\r\n    this._npmConfig.version = newVersion;\r\n\r\n    const dependencyNames = this._packages.map(item => item.name);\r\n\r\n    const fn = (currDeps: { [key: string]: string | undefined } | undefined): void => {\r\n      if (currDeps) {\r\n        for (const dependencyName of dependencyNames) {\r\n          if (currDeps[dependencyName] !== undefined) {\r\n            currDeps[dependencyName] = newVersion;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    fn(this._npmConfig.dependencies);\r\n    fn(this._npmConfig.devDependencies);\r\n    fn(this._npmConfig.peerDependencies);\r\n\r\n    await FsUtils.writeJsonAsync(this._npmConfigPath, this._npmConfig, {space: 2});\r\n  }\r\n\r\n  private async _parallelPackagesByDepAsync(cb: (pkg: SdCliPackage) => Promise<void>): Promise<void> {\r\n    const completedPackageNames: string[] = [];\r\n\r\n    await this._packages.parallelAsync(async pkg => {\r\n      // 패키지의 의존성 패키지 중에 빌드해야할 패키지 목록에 이미 있는 의존성 패키지만 추리기\r\n      const depNames = pkg.dependencies.filter(dep => (\r\n        this._packages.some(targetPkg => targetPkg.name === dep)\r\n      ));\r\n\r\n      // 추려진 의존성 패키지별로 의존성 패키지의 빌드가 완료될때까지 기다리기\r\n      await depNames.parallelAsync(async depName => {\r\n        await Wait.true(() => completedPackageNames.includes(depName));\r\n      });\r\n\r\n      await cb(pkg);\r\n\r\n      completedPackageNames.push(pkg.name);\r\n    });\r\n  }\r\n\r\n  private async _stopServerAsync(pkg: SdCliPackage): Promise<void> {\r\n    if (pkg.entryFilePath === undefined) {\r\n      throw new Error(\"서버 빌드시, 'package.json'에 'main'이 반드시 설정되어 있어야 합니다.\");\r\n    }\r\n\r\n    if (!this._servers[pkg.name]?.server) return;\r\n\r\n    if (this._servers[pkg.name]?.server) {\r\n      this._logger.log(`[${pkg.name}] 서버를 재시작합니다.`);\r\n\r\n      await this._servers[pkg.name].server!.closeAsync();\r\n      delete this._servers[pkg.name].server;\r\n      decache(pkg.entryFilePath);\r\n    }\r\n  }\r\n\r\n  private async _startServerAsync(pkg: SdCliPackage): Promise<void> {\r\n    if (pkg.entryFilePath === undefined) {\r\n      throw new Error(\"서버 빌드시, 'package.json'에 'main'이 반드시 설정되어 있어야 합니다.\");\r\n    }\r\n\r\n    try {\r\n      await Wait.true(() => (\r\n        !this._servers[pkg.name]?.server &&\r\n        pkg.entryFilePath !== undefined &&\r\n        FsUtils.exists(pkg.entryFilePath)\r\n      ));\r\n      await Wait.time(1000);\r\n\r\n      const server = require(pkg.entryFilePath) as SdServiceServer | undefined;\r\n      if (!server) {\r\n        this._logger.error(`[${pkg.name}] '${pkg.entryFilePath}'에서 'SdServiceServer'를 'export'하고있지 않습니다.`);\r\n        return;\r\n      }\r\n\r\n      if (!server.on) {\r\n        throw new NeverEntryError();\r\n      }\r\n\r\n      this._servers[pkg.name] = this._servers[pkg.name] ?? {middlewares: {}};\r\n      server.middlewares = Object.values(this._servers[pkg.name].middlewares).mapMany();\r\n\r\n      this._servers[pkg.name].server = server;\r\n\r\n      server.on(\"ready\", () => {\r\n        this._logger.info(`[${pkg.name}] 서버가 시작되었습니다.`);\r\n      });\r\n    }\r\n    catch (err) {\r\n      this._logger.error(`[${pkg.name}] 서버를 시작할 수 없습니다.${os.EOL}`, err);\r\n    }\r\n  }\r\n\r\n  private async _registerClientAsync(pkg: SdCliPackage, middlewares: NextHandleFunction[]): Promise<void> {\r\n    if (pkg.info.config?.type !== \"web\") throw new NeverEntryError();\r\n\r\n    this._servers[pkg.info.config.server] = this._servers[pkg.info.config.server] ?? {middlewares: {}};\r\n    this._servers[pkg.info.config.server].middlewares[pkg.name] = middlewares;\r\n\r\n    await Wait.true(() => this._servers[pkg.info.config![\"server\"]].server !== undefined);\r\n\r\n    await FsUtils.writeJsonAsync(\r\n      path.resolve(\r\n        this._servers[pkg.info.config[\"server\"]].server!.rootPath,\r\n        \"www\",\r\n        path.basename(pkg.info.rootPath),\r\n        \".configs.json\"\r\n      ),\r\n      pkg.info.config.configs\r\n    );\r\n\r\n    this._servers[pkg.info.config.server].server!.middlewares =\r\n      Object.values(this._servers[pkg.info.config.server].middlewares).mapMany();\r\n\r\n    // const port = this._servers[pkg.info.config.server].server!.options.port ?? 80;\r\n    // this._logger.info(`[${pkg.name}] 클라이언트가 준비되었습니다.: http://localhost:${port}/${path.basename(pkg.info.rootPath)}/`);\r\n  }\r\n\r\n}","D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\bin.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-worker.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\commons.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdAngularUtils.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdWebpackWriteFilePlugin.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdWebpackInputHostWithScss.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\inline-sass-loader.ts",[],"D:\\workspaces_new\\simplysm\\packages\\sd-cli\\src\\build-tools\\SdTypescriptWatcher.ts",[],{"ruleId":"100","severity":1,"message":"101","line":309,"column":5,"nodeType":"102","endLine":309,"endColumn":63},"no-warning-comments","Unexpected 'todo' comment.","Line"]