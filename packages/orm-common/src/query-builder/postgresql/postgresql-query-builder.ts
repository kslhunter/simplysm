import type {
  AddColumnQueryDef,
  AddFkQueryDef,
  AddIdxQueryDef,
  AddPkQueryDef,
  ClearSchemaQueryDef,
  CreateProcQueryDef,
  CreateTableQueryDef,
  CreateViewQueryDef,
  SchemaExistsQueryDef,
  DeleteQueryDef,
  DropColumnQueryDef,
  DropFkQueryDef,
  DropIdxQueryDef,
  DropPkQueryDef,
  DropProcQueryDef,
  DropTableQueryDef,
  DropViewQueryDef,
  ExecProcQueryDef,
  InsertIfNotExistsQueryDef,
  InsertIntoQueryDef,
  InsertQueryDef,
  ModifyColumnQueryDef,
  QueryDefObjectName,
  RenameColumnQueryDef,
  RenameTableQueryDef,
  SelectQueryDef,
  SelectQueryDefJoin,
  SwitchFkQueryDef,
  TruncateQueryDef,
  UpdateQueryDef,
  UpsertQueryDef,
} from "../../types/query-def";
import type { QueryBuildResult } from "../../types/db";
import { QueryBuilderBase } from "../base/query-builder-base";
import { PostgresqlExprRenderer } from "./postgresql-expr-renderer";

/**
 * PostgreSQL QueryBuilder
 *
 * PostgreSQL 특이사항:
 * - OUTPUT: RETURNING 절 사용 (네이티브 지원)
 * - TRUNCATE: RESTART IDENTITY option 필요
 * - UPSERT: CTE 방식 (INSERT ... ON CONFLICT는 단일 unique 제약만 지원)
 * - AUTO_INCREMENT: GENERATED BY DEFAULT AS IDENTITY (explicit value 지정 가능)
 * - FK Add 시 Index 별도 Generate 필요 (MySQL과 달리)
 */
export class PostgresqlQueryBuilder extends QueryBuilderBase {
  protected expr = new PostgresqlExprRenderer((def) => this.select(def).sql);

  //#region ========== 유틸리티 ==========

  /** Table명 Render (PostgreSQL: database는 connection에서 processing, schema.table만 사용) */
  protected tableName(obj: QueryDefObjectName): string {
    const schema = obj.schema ?? "public";
    return `${this.expr.wrap(schema)}.${this.expr.wrap(obj.name)}`;
  }

  /** LIMIT...OFFSET 절 Render */
  protected renderLimit(limit: [number, number] | undefined, top: number | undefined): string {
    if (limit != null) {
      const [offset, count] = limit;
      return ` LIMIT ${count} OFFSET ${offset}`;
    }
    if (top != null) {
      return ` LIMIT ${top}`;
    }
    return "";
  }

  protected renderJoin(join: SelectQueryDefJoin): string {
    const alias = this.expr.wrap(join.as);

    // LATERAL JOIN 필요 여부 감지
    if (this.needsLateral(join)) {
      // from이 배열(UNION ALL)이면 renderFrom(join.from),
      // 그 외(orderBy, top, select 등)면 renderFrom(join)으로 Subquery Generate
      const from = Array.isArray(join.from) ? this.renderFrom(join.from) : this.renderFrom(join);
      return ` LEFT OUTER JOIN LATERAL ${from} AS ${alias} ON TRUE`;
    }

    // 일반 JOIN
    const from = this.renderFrom(join.from);
    const where =
      join.where != null && join.where.length > 0
        ? ` ON ${this.expr.renderWhere(join.where)}`
        : " ON TRUE";
    return ` LEFT OUTER JOIN ${from} AS ${alias}${where}`;
  }

  //#endregion

  //#region ========== DML - SELECT ==========

  protected select(def: SelectQueryDef): QueryBuildResult {
    // WITH (CTE)
    let sql = "";
    if (def.with != null) {
      const { name, base, recursive } = def.with;
      sql += `WITH RECURSIVE ${this.expr.wrap(name)} AS (${this.select(base).sql} UNION ALL ${this.select(recursive).sql}) `;
    }

    // SELECT
    sql += "SELECT";
    if (def.distinct) {
      sql += " DISTINCT";
    }

    // columns
    if (def.select != null) {
      const cols = Object.entries(def.select).map(
        ([alias, expr]) => `${this.expr.render(expr)} AS ${this.expr.wrap(alias)}`,
      );
      sql += ` ${cols.join(", ")}`;
    } else {
      sql += " *";
    }

    // FROM
    if (def.from != null) {
      const from = this.renderFrom(def.from);
      sql += ` FROM ${from} AS ${this.expr.wrap(def.as)}`;
    }

    // JOINs
    sql += this.renderJoins(def.joins);

    // WHERE
    sql += this.renderWhere(def.where);

    // GROUP BY
    sql += this.renderGroupBy(def.groupBy);

    // HAVING
    sql += this.renderHaving(def.having);

    // ORDER BY
    sql += this.renderOrderBy(def.orderBy);

    // LIMIT
    sql += this.renderLimit(def.limit, def.top);

    // LOCK (FOR UPDATE at end)
    if (def.lock) {
      sql += " FOR UPDATE";
    }

    return { sql };
  }

  //#endregion

  //#region ========== DML - INSERT ==========

  protected insert(def: InsertQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);

    if (def.records.length === 0) {
      throw new Error("INSERT requires at least one record.");
    }

    const columns = Object.keys(def.records[0]);
    const colList = columns.map((c) => this.expr.wrap(c)).join(", ");

    const valuesList = def.records.map((record) => {
      const values = columns.map((c) => this.expr.escapeValue(record[c]));
      return `(${values.join(", ")})`;
    });

    let sql = `INSERT INTO ${table} (${colList})`;

    // GENERATED BY DEFAULT AS IDENTITY이므로 explicit value 삽입 시 Add 구문 불필요
    // overrideIdentity 파라미터는 MSSQL(SET IDENTITY_INSERT) 호환성을 위해 유지되지만
    // PostgreSQL에서는 GENERATED BY DEFAULT가 automatic으로 explicit 값을 허용함
    // (참고: GENERATED ALWAYS였다면 OVERRIDING SYSTEM VALUE 필요)

    sql += ` VALUES ${valuesList.join(", ")}`;

    // RETURNING (PostgreSQL 네이티브 지원)
    if (def.output != null) {
      const outputCols = def.output.columns.map((c) => this.expr.wrap(c)).join(", ");
      sql += ` RETURNING ${outputCols}`;
    }

    return { sql };
  }

  protected insertIfNotExists(def: InsertIfNotExistsQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);

    const columns = Object.keys(def.record);
    const colList = columns.map((c) => this.expr.wrap(c)).join(", ");
    const values = columns.map((c) => this.expr.escapeValue(def.record[c])).join(", ");

    // existsSelectQuery를 SELECT 1 AS _ 형태로 Render
    const existsQuerySql = this.select({
      ...def.existsSelectQuery,
      select: { _: { type: "value", value: 1 } },
    }).sql;

    let sql = `INSERT INTO ${table} (${colList}) SELECT ${values} WHERE NOT EXISTS (${existsQuerySql})`;

    // RETURNING
    if (def.output != null) {
      const outputCols = def.output.columns.map((c) => this.expr.wrap(c)).join(", ");
      sql += ` RETURNING ${outputCols}`;
    }

    return { sql };
  }

  protected insertInto(def: InsertIntoQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const selectSql = this.select(def.recordsSelectQuery).sql;

    // INSERT INTO SELECT에서 columns 추출
    const selectDef = def.recordsSelectQuery;
    const colList =
      selectDef.select != null
        ? Object.keys(selectDef.select)
            .map((c) => this.expr.wrap(c))
            .join(", ")
        : "*";

    let sql = `INSERT INTO ${table} (${colList}) ${selectSql}`;

    // RETURNING
    if (def.output != null) {
      const outputCols = def.output.columns.map((c) => this.expr.wrap(c)).join(", ");
      sql += ` RETURNING ${outputCols}`;
    }

    return { sql };
  }

  //#endregion

  //#region ========== DML - UPDATE ==========

  protected update(def: UpdateQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const alias = this.expr.wrap(def.as);

    // SET
    const setParts = Object.entries(def.record).map(
      ([col, e]) => `${this.expr.wrap(col)} = ${this.expr.render(e)}`,
    );

    let sql = `UPDATE ${table} AS ${alias} SET ${setParts.join(", ")}`;

    // PostgreSQL: JOIN은 FROM 절로 processing
    if (def.joins != null && def.joins.length > 0) {
      const joinTables = def.joins.map((j) => {
        const from = this.renderFrom(j.from);
        return `${from} AS ${this.expr.wrap(j.as)}`;
      });
      sql += ` FROM ${joinTables.join(", ")}`;

      // JOIN ON 조건을 WHERE에 Add
      const joinConditions = def.joins
        .filter((j) => j.where != null && j.where.length > 0)
        .map((j) => this.expr.renderWhere(j.where!));
      if (joinConditions.length > 0) {
        const whereCondition =
          def.where != null && def.where.length > 0 ? this.expr.renderWhere(def.where) : null;
        const allConditions =
          whereCondition != null ? [whereCondition, ...joinConditions] : joinConditions;
        sql += ` WHERE ${allConditions.join(" AND ")}`;
      } else {
        sql += this.renderWhere(def.where);
      }
    } else {
      sql += this.renderWhere(def.where);
    }

    // RETURNING
    if (def.output != null) {
      const outputCols = def.output.columns.map((c) => `${alias}.${this.expr.wrap(c)}`).join(", ");
      sql += ` RETURNING ${outputCols}`;
    }

    return { sql };
  }

  //#endregion

  //#region ========== DML - DELETE ==========

  protected delete(def: DeleteQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const alias = this.expr.wrap(def.as);

    let sql = `DELETE FROM ${table} AS ${alias}`;

    // PostgreSQL: JOIN은 USING 절로 processing
    if (def.joins != null && def.joins.length > 0) {
      const joinTables = def.joins.map((j) => {
        const from = this.renderFrom(j.from);
        return `${from} AS ${this.expr.wrap(j.as)}`;
      });
      sql += ` USING ${joinTables.join(", ")}`;

      // JOIN ON 조건을 WHERE에 Add
      const joinConditions = def.joins
        .filter((j) => j.where != null && j.where.length > 0)
        .map((j) => this.expr.renderWhere(j.where!));
      if (joinConditions.length > 0) {
        const whereCondition =
          def.where != null && def.where.length > 0 ? this.expr.renderWhere(def.where) : null;
        const allConditions =
          whereCondition != null ? [whereCondition, ...joinConditions] : joinConditions;
        sql += ` WHERE ${allConditions.join(" AND ")}`;
      } else {
        sql += this.renderWhere(def.where);
      }
    } else {
      sql += this.renderWhere(def.where);
    }

    // RETURNING (PostgreSQL: DELETE에서도 지원)
    if (def.output != null) {
      const outputCols = def.output.columns.map((c) => this.expr.wrap(c)).join(", ");
      sql += ` RETURNING ${outputCols}`;
    }

    return { sql };
  }

  //#endregion

  //#region ========== DML - UPSERT ==========

  protected upsert(def: UpsertQueryDef): QueryBuildResult {
    // PostgreSQL: CTE 방식 (ON CONFLICT는 단일 unique 제약만 지원하므로 범용성 위해 CTE 사용)
    const table = this.tableName(def.table);
    const alias = this.expr.wrap(def.existsSelectQuery.as);

    // UPDATE SET part
    const updateSetParts = Object.entries(def.updateRecord).map(
      ([col, e]) => `${this.expr.wrap(col)} = ${this.expr.render(e)}`,
    );

    // INSERT part
    const insertColumns = Object.keys(def.insertRecord);
    const insertColList = insertColumns.map((c) => this.expr.wrap(c)).join(", ");
    const insertValues = insertColumns.map((c) => this.expr.render(def.insertRecord[c])).join(", ");

    // WHERE condition
    const whereCondition =
      def.existsSelectQuery.where != null && def.existsSelectQuery.where.length > 0
        ? this.expr.renderWhere(def.existsSelectQuery.where)
        : "TRUE";

    // OUTPUT column
    const outputCols =
      def.output != null ? def.output.columns.map((c) => this.expr.wrap(c)).join(", ") : "*";

    // CTE 방식 UPSERT
    let sql = `WITH matched AS (\n`;
    sql += `  SELECT ${alias}.* FROM ${table} AS ${alias} WHERE ${whereCondition}\n`;
    sql += `),\n`;
    sql += `updated AS (\n`;
    sql += `  UPDATE ${table} AS ${alias} SET ${updateSetParts.join(", ")}\n`;
    sql += `  WHERE ${whereCondition}\n`;
    sql += `  RETURNING ${outputCols}\n`;
    sql += `),\n`;
    sql += `inserted AS (\n`;
    sql += `  INSERT INTO ${table} (${insertColList})\n`;
    sql += `  SELECT ${insertValues}\n`;
    sql += `  WHERE NOT EXISTS (SELECT 1 FROM matched)\n`;
    sql += `  RETURNING ${outputCols}\n`;
    sql += `)\n`;
    sql += `SELECT * FROM updated UNION ALL SELECT * FROM inserted`;

    return { sql };
  }

  //#endregion

  //#region ========== DDL - Table ==========

  protected createTable(def: CreateTableQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);

    const colDefs = def.columns.map((col) => {
      let colSql = `${this.expr.wrap(col.name)} ${this.expr.renderDataType(col.dataType)}`;

      // nullable: true → NULL, else → NOT NULL
      if (col.nullable === true) {
        colSql += " NULL";
      } else {
        colSql += " NOT NULL";
      }

      if (col.autoIncrement) {
        colSql += " GENERATED BY DEFAULT AS IDENTITY";
      }

      if (col.default !== undefined) {
        colSql += ` DEFAULT ${this.expr.escapeValue(col.default)}`;
      }

      return colSql;
    });

    // Primary Key with CONSTRAINT name
    if (def.primaryKey != null && def.primaryKey.length > 0) {
      const pkCols = def.primaryKey.map((c) => this.expr.wrap(c)).join(", ");
      const pkName = this.expr.wrap(`PK_${def.table.name}`);
      colDefs.push(`CONSTRAINT ${pkName} PRIMARY KEY (${pkCols})`);
    }

    return { sql: `CREATE TABLE ${table} (\n  ${colDefs.join(",\n  ")}\n)` };
  }

  protected dropTable(def: DropTableQueryDef): QueryBuildResult {
    return { sql: `DROP TABLE ${this.tableName(def.table)}` };
  }

  protected renameTable(def: RenameTableQueryDef): QueryBuildResult {
    return {
      sql: `ALTER TABLE ${this.tableName(def.table)} RENAME TO ${this.expr.wrap(def.newName)}`,
    };
  }

  protected truncate(def: TruncateQueryDef): QueryBuildResult {
    // PostgreSQL: RESTART IDENTITY로 시퀀스 리셋
    return { sql: `TRUNCATE TABLE ${this.tableName(def.table)} RESTART IDENTITY` };
  }

  //#endregion

  //#region ========== DDL - Column ==========

  protected addColumn(def: AddColumnQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const col = def.column;

    let colSql = `${this.expr.wrap(col.name)} ${this.expr.renderDataType(col.dataType)}`;

    // nullable: true → NULL, else → NOT NULL
    if (col.nullable === true) {
      colSql += " NULL";
    } else {
      colSql += " NOT NULL";
    }

    if (col.autoIncrement) {
      colSql += " GENERATED BY DEFAULT AS IDENTITY";
    }

    if (col.default !== undefined) {
      colSql += ` DEFAULT ${this.expr.escapeValue(col.default)}`;
    }

    return { sql: `ALTER TABLE ${table} ADD COLUMN ${colSql}` };
  }

  protected dropColumn(def: DropColumnQueryDef): QueryBuildResult {
    return {
      sql: `ALTER TABLE ${this.tableName(def.table)} DROP COLUMN ${this.expr.wrap(def.column)}`,
    };
  }

  protected modifyColumn(def: ModifyColumnQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const col = def.column;

    // PostgreSQL: ALTER COLUMN은 여러 ALTER 필요
    const parts: string[] = [];

    // TYPE 변경
    parts.push(
      `ALTER COLUMN ${this.expr.wrap(col.name)} TYPE ${this.expr.renderDataType(col.dataType)}`,
    );

    // NULL 변경
    if (col.nullable === false) {
      parts.push(`ALTER COLUMN ${this.expr.wrap(col.name)} SET NOT NULL`);
    } else {
      parts.push(`ALTER COLUMN ${this.expr.wrap(col.name)} DROP NOT NULL`);
    }

    // DEFAULT 변경
    if (col.default !== undefined) {
      parts.push(
        `ALTER COLUMN ${this.expr.wrap(col.name)} SET DEFAULT ${this.expr.escapeValue(col.default)}`,
      );
    }

    return { sql: `ALTER TABLE ${table} ${parts.join(", ")}` };
  }

  protected renameColumn(def: RenameColumnQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    return {
      sql: `ALTER TABLE ${table} RENAME COLUMN ${this.expr.wrap(def.column)} TO ${this.expr.wrap(def.newName)}`,
    };
  }

  //#endregion

  //#region ========== DDL - Constraint ==========

  protected addPk(def: AddPkQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const cols = def.columns.map((c) => this.expr.wrap(c)).join(", ");
    const pkName = `PK_${def.table.name}`;
    return {
      sql: `ALTER TABLE ${table} ADD CONSTRAINT ${this.expr.wrap(pkName)} PRIMARY KEY (${cols})`,
    };
  }

  protected dropPk(def: DropPkQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const pkName = `PK_${def.table.name}`;
    return { sql: `ALTER TABLE ${table} DROP CONSTRAINT ${this.expr.wrap(pkName)}` };
  }

  protected addFk(def: AddFkQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const fk = def.foreignKey;
    const fkCols = fk.fkColumns.map((c) => this.expr.wrap(c)).join(", ");
    const targetTable = this.tableName(fk.targetTable);
    const targetCols = fk.targetPkColumns.map((c) => this.expr.wrap(c)).join(", ");

    let sql = `ALTER TABLE ${table} ADD CONSTRAINT ${this.expr.wrap(fk.name)} FOREIGN KEY (${fkCols}) REFERENCES ${targetTable} (${targetCols})`;

    // PostgreSQL: FK용 Index 별도 Generate 필요
    const idxName = `IDX_${def.table.name}_${fk.name.replace(/^FK_/, "")}`;
    sql += `;\nCREATE INDEX ${this.expr.wrap(idxName)} ON ${table} (${fkCols});`;

    return { sql };
  }

  protected dropFk(def: DropFkQueryDef): QueryBuildResult {
    return {
      sql: `ALTER TABLE ${this.tableName(def.table)} DROP CONSTRAINT ${this.expr.wrap(def.foreignKey)}`,
    };
  }

  protected addIdx(def: AddIdxQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    const idx = def.index;
    const cols = idx.columns.map((c) => `${this.expr.wrap(c.name)} ${c.orderBy}`).join(", ");
    const unique = idx.unique ? "UNIQUE " : "";
    return { sql: `CREATE ${unique}INDEX ${this.expr.wrap(idx.name)} ON ${table} (${cols})` };
  }

  protected dropIdx(def: DropIdxQueryDef): QueryBuildResult {
    // PostgreSQL: Index는 schema 레벨에서 유니크하므로 Table명 불필요하지만 스키마는 명시 필요
    const schema = def.table.schema ?? "public";
    return { sql: `DROP INDEX ${this.expr.wrap(schema)}.${this.expr.wrap(def.index)}` };
  }

  //#endregion

  //#region ========== DDL - View/Procedure ==========

  protected createView(def: CreateViewQueryDef): QueryBuildResult {
    const view = this.tableName(def.view);
    const selectSql = this.select(def.queryDef).sql;
    return { sql: `CREATE OR REPLACE VIEW ${view} AS ${selectSql}` };
  }

  protected dropView(def: DropViewQueryDef): QueryBuildResult {
    return { sql: `DROP VIEW IF EXISTS ${this.tableName(def.view)}` };
  }

  protected createProc(def: CreateProcQueryDef): QueryBuildResult {
    const proc = this.tableName(def.procedure);

    // params processing
    const paramList =
      def.params
        ?.map((p) => {
          let sql = `${this.expr.wrap(p.name)} ${this.expr.renderDataType(p.dataType)}`;
          if (p.default !== undefined) {
            sql += ` DEFAULT ${this.expr.escapeValue(p.default)}`;
          }
          return sql;
        })
        .join(", ") ?? "";

    // returns processing
    let returnClause = "VOID";
    if (def.returns && def.returns.length > 0) {
      const returnFields = def.returns
        .map((r) => `${this.expr.wrap(r.name)} ${this.expr.renderDataType(r.dataType)}`)
        .join(", ");
      returnClause = `TABLE(${returnFields})`;
    }

    let sql = `CREATE OR REPLACE FUNCTION ${proc}(${paramList})\n`;
    sql += `RETURNS ${returnClause} AS $$\n`;
    sql += `BEGIN\n`;
    sql += def.query;
    if (!def.query.trim().endsWith(";")) {
      sql += ";";
    }
    sql += `\nEND;\n`;
    sql += `$$ LANGUAGE plpgsql`;

    return { sql };
  }

  protected dropProc(def: DropProcQueryDef): QueryBuildResult {
    return { sql: `DROP FUNCTION IF EXISTS ${this.tableName(def.procedure)}()` };
  }

  protected execProc(def: ExecProcQueryDef): QueryBuildResult {
    const proc = this.tableName(def.procedure);
    if (def.params == null || Object.keys(def.params).length === 0) {
      return { sql: `SELECT ${proc}()` };
    }
    const params = Object.values(def.params)
      .map((p) => this.expr.render(p))
      .join(", ");
    return { sql: `SELECT ${proc}(${params})` };
  }

  //#endregion

  //#region ========== Utils ==========

  protected clearSchema(def: ClearSchemaQueryDef): QueryBuildResult {
    const schemaName = def.schema ?? "public";
    // SQL Injection 방어: 스키마명 유효성 Validation
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(schemaName)) {
      throw new Error(`Invalid schema name: ${schemaName}`);
    }
    const schema = this.expr.escapeString(schemaName);
    return {
      sql: `
DO $$
DECLARE
  r RECORD;
BEGIN
  -- FK constraint Delete
  FOR r IN (SELECT conname, conrelid::regclass AS tablename
            FROM pg_constraint
            WHERE contype = 'f' AND connamespace = '${schema}'::regnamespace)
  LOOP
    EXECUTE 'ALTER TABLE ' || r.tablename || ' DROP CONSTRAINT ' || quote_ident(r.conname);
  END LOOP;

  -- Drop table
  FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = '${schema}')
  LOOP
    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
  END LOOP;

  -- Drop view
  FOR r IN (SELECT viewname FROM pg_views WHERE schemaname = '${schema}')
  LOOP
    EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.viewname) || ' CASCADE';
  END LOOP;

  -- function Delete
  FOR r IN (SELECT proname, pg_get_function_identity_arguments(oid) AS args
            FROM pg_proc WHERE pronamespace = '${schema}'::regnamespace)
  LOOP
    EXECUTE 'DROP FUNCTION IF EXISTS ' || quote_ident(r.proname) || '(' || r.args || ') CASCADE';
  END LOOP;
END $$`,
    };
  }

  protected schemaExists(def: SchemaExistsQueryDef): QueryBuildResult {
    const schemaName = def.schema ?? "public";
    const schema = this.expr.escapeString(schemaName);
    return { sql: `SELECT nspname FROM pg_namespace WHERE nspname = '${schema}'` };
  }

  protected switchFk(def: SwitchFkQueryDef): QueryBuildResult {
    const table = this.tableName(def.table);
    if (def.switch === "on") {
      // PostgreSQL: Table의 모든 FK 트리거 Enable
      return { sql: `ALTER TABLE ${table} ENABLE TRIGGER ALL` };
    }
    // PostgreSQL: Table의 모든 FK 트리거 Disable
    return { sql: `ALTER TABLE ${table} DISABLE TRIGGER ALL` };
  }

  //#endregion
}
