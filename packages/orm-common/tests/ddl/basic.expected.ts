import { mysql, pgsql, tsql } from "@simplysm/core-common";
import type { ExpectedSql } from "../setup/test-utils";

//#region ========== Database ==========

export const clearSchema: ExpectedSql = {
  mysql: mysql`
SET FOREIGN_KEY_CHECKS = 0;
SET @tables = NULL;
SELECT GROUP_CONCAT(table_name) INTO @tables FROM information_schema.tables WHERE table_schema = 'TestDb';
SET @drop_stmt = IF(@tables IS NULL, 'SELECT 1', CONCAT('DROP TABLE IF EXISTS ', @tables));
PREPARE stmt FROM @drop_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1
  `,
  mssql: tsql`
DECLARE @sql NVARCHAR(MAX);
SET @sql = N'';

-- FK constraint Delete
SELECT @sql = @sql + N'ALTER TABLE ' + QUOTENAME(OBJECT_SCHEMA_NAME(parent_object_id)) + '.' + QUOTENAME(OBJECT_NAME(parent_object_id)) + N' DROP CONSTRAINT ' + QUOTENAME(name) + N';' + CHAR(13)
FROM [TestDb].sys.foreign_keys
WHERE OBJECT_SCHEMA_NAME(parent_object_id) = 'TestSchema';

-- Drop table
SELECT @sql = @sql + N'DROP TABLE ' + QUOTENAME(SCHEMA_NAME(schema_id)) + '.' + QUOTENAME(name) + N';' + CHAR(13)
FROM [TestDb].sys.tables
WHERE SCHEMA_NAME(schema_id) = 'TestSchema';

-- Drop view
SELECT @sql = @sql + N'DROP VIEW ' + QUOTENAME(SCHEMA_NAME(schema_id)) + '.' + QUOTENAME(name) + N';' + CHAR(13)
FROM [TestDb].sys.views
WHERE schema_id = SCHEMA_ID('TestSchema');

-- Procedure Delete
SELECT @sql = @sql + N'DROP PROCEDURE ' + QUOTENAME(SCHEMA_NAME(schema_id)) + '.' + QUOTENAME(name) + N';' + CHAR(13)
FROM [TestDb].sys.procedures
WHERE SCHEMA_NAME(schema_id) = 'TestSchema';

EXEC sp_executesql @sql;
  `,
  postgresql: pgsql`
DO $$
DECLARE
  r RECORD;
BEGIN
  -- FK constraint Delete
  FOR r IN (SELECT conname, conrelid::regclass AS tablename
            FROM pg_constraint
            WHERE contype = 'f' AND connamespace = 'TestSchema'::regnamespace)
  LOOP
    EXECUTE 'ALTER TABLE ' || r.tablename || ' DROP CONSTRAINT ' || quote_ident(r.conname);
  END LOOP;

  -- Drop table
  FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'TestSchema')
  LOOP
    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
  END LOOP;

  -- Drop view
  FOR r IN (SELECT viewname FROM pg_views WHERE schemaname = 'TestSchema')
  LOOP
    EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.viewname) || ' CASCADE';
  END LOOP;

  -- function Delete
  FOR r IN (SELECT proname, pg_get_function_identity_arguments(oid) AS args
            FROM pg_proc WHERE pronamespace = 'TestSchema'::regnamespace)
  LOOP
    EXECUTE 'DROP FUNCTION IF EXISTS ' || quote_ident(r.proname) || '(' || r.args || ') CASCADE';
  END LOOP;
END $$
  `,
};

export const schemaExists: ExpectedSql = {
  mysql: mysql`SELECT SCHEMA_NAME FROM information_schema.SCHEMATA WHERE SCHEMA_NAME = 'TestDb'`,
  mssql: tsql`
DECLARE @result NVARCHAR(MAX) = NULL;
IF EXISTS (SELECT 1 FROM sys.databases WHERE name = 'TestDb')
BEGIN
  DECLARE @sql NVARCHAR(MAX) = N'SELECT @result = name FROM ' + QUOTENAME('TestDb') + N'.sys.schemas WHERE name = ''TestSchema''';
  EXEC sp_executesql @sql, N'@result NVARCHAR(MAX) OUTPUT', @result OUTPUT;
END
SELECT @result AS name WHERE @result IS NOT NULL
  `,
  postgresql: pgsql`SELECT nspname FROM pg_namespace WHERE nspname = 'TestSchema'`,
};

//#endregion

//#region ========== Table ==========

export const createTable: ExpectedSql = {
  mysql: mysql`
CREATE TABLE \`TestDb\`.\`User\` (
  \`id\` BIGINT NOT NULL AUTO_INCREMENT,
  \`name\` VARCHAR(100) NOT NULL,
  \`email\` VARCHAR(200) NULL,
  \`age\` INT NULL,
  \`isActive\` BOOLEAN NOT NULL DEFAULT TRUE,
  \`companyId\` BIGINT NULL,
  \`createdAt\` DATETIME NOT NULL,
  CONSTRAINT \`PK_User\` PRIMARY KEY (\`id\`)
)
  `,
  mssql: tsql`
CREATE TABLE [TestDb].[TestSchema].[User] (
  [id] BIGINT NOT NULL IDENTITY(1,1),
  [name] NVARCHAR(100) NOT NULL,
  [email] NVARCHAR(200) NULL,
  [age] INT NULL,
  [isActive] BIT NOT NULL DEFAULT 1,
  [companyId] BIGINT NULL,
  [createdAt] DATETIME2 NOT NULL,
  CONSTRAINT [PK_User] PRIMARY KEY ([id])
)
  `,
  postgresql: pgsql`
CREATE TABLE "TestSchema"."User" (
  "id" BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  "name" VARCHAR(100) NOT NULL,
  "email" VARCHAR(200) NULL,
  "age" INTEGER NULL,
  "isActive" BOOLEAN NOT NULL DEFAULT TRUE,
  "companyId" BIGINT NULL,
  "createdAt" TIMESTAMP NOT NULL,
  CONSTRAINT "PK_User" PRIMARY KEY ("id")
)
  `,
};

export const truncate: ExpectedSql = {
  mysql: mysql`TRUNCATE TABLE \`TestDb\`.\`User\``,
  mssql: tsql`TRUNCATE TABLE [TestDb].[TestSchema].[User]`,
  postgresql: pgsql`TRUNCATE TABLE "TestSchema"."User" RESTART IDENTITY`,
};

export const switchFkOn: ExpectedSql = {
  mysql: mysql`SET FOREIGN_KEY_CHECKS = 1`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] WITH CHECK CHECK CONSTRAINT ALL`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ENABLE TRIGGER ALL`,
};

export const switchFkOff: ExpectedSql = {
  mysql: mysql`SET FOREIGN_KEY_CHECKS = 0`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] NOCHECK CONSTRAINT ALL`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" DISABLE TRIGGER ALL`,
};

export const dropTable: ExpectedSql = {
  mysql: mysql`DROP TABLE \`TestDb\`.\`User\``,
  mssql: tsql`DROP TABLE [TestDb].[TestSchema].[User]`,
  postgresql: pgsql`DROP TABLE "TestSchema"."User"`,
};

export const renameTable: ExpectedSql = {
  mysql: mysql`RENAME TABLE \`TestDb\`.\`User\` TO \`Member\``,
  mssql: tsql`EXEC sp_rename '[TestDb].[TestSchema].[User]', 'Member'`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" RENAME TO "Member"`,
};

//#endregion

//#region ========== Column ==========

export const addColumn: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` ADD COLUMN \`nickname\` VARCHAR(50) NULL`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ADD [nickname] NVARCHAR(50) NULL`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ADD COLUMN "nickname" VARCHAR(50) NULL`,
};

export const addColumnWithDefault: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` ADD COLUMN \`score\` INT NOT NULL DEFAULT 0`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ADD [score] INT NOT NULL DEFAULT 0`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ADD COLUMN "score" INTEGER NOT NULL DEFAULT 0`,
};

export const addColumnWithAutoIncrement: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` ADD COLUMN \`seq\` BIGINT NOT NULL AUTO_INCREMENT`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ADD [seq] BIGINT NOT NULL IDENTITY(1,1)`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ADD COLUMN "seq" BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY`,
};

export const dropColumn: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` DROP COLUMN \`email\``,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] DROP COLUMN [email]`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" DROP COLUMN "email"`,
};

export const modifyColumn: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` MODIFY COLUMN \`name\` VARCHAR(200) NULL`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ALTER COLUMN [name] NVARCHAR(200) NULL`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ALTER COLUMN "name" TYPE VARCHAR(200), ALTER COLUMN "name" DROP NOT NULL`,
};

export const modifyColumnTypeAndDefault: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` MODIFY COLUMN \`score\` INT NOT NULL DEFAULT 100`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ALTER COLUMN [score] INT NOT NULL`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ALTER COLUMN "score" TYPE INTEGER, ALTER COLUMN "score" DROP NOT NULL, ALTER COLUMN "score" SET DEFAULT 100`,
};

export const renameColumn: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` RENAME COLUMN \`name\` TO \`fullName\``,
  mssql: tsql`EXEC sp_rename '[TestDb].[TestSchema].[User].name', 'fullName', 'COLUMN'`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" RENAME COLUMN "name" TO "fullName"`,
};

//#endregion

//#region ========== Primary Key ==========

export const dropPk: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` DROP PRIMARY KEY`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] DROP CONSTRAINT [PK_User]`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" DROP CONSTRAINT "PK_User"`,
};

export const addPk: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`User\` ADD PRIMARY KEY (\`id\`)`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[User] ADD CONSTRAINT [PK_User] PRIMARY KEY ([id])`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."User" ADD CONSTRAINT "PK_User" PRIMARY KEY ("id")`,
};

export const addPkComposite: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`UserRole\` ADD PRIMARY KEY (\`userId\`, \`roleId\`)`,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[UserRole] ADD CONSTRAINT [PK_UserRole] PRIMARY KEY ([userId], [roleId])`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."UserRole" ADD CONSTRAINT "PK_UserRole" PRIMARY KEY ("userId", "roleId")`,
};

//#endregion

//#region ========== Foreign Key / Index ==========

export const addFk: ExpectedSql = {
  mysql: mysql`
ALTER TABLE \`TestDb\`.\`Post\` ADD CONSTRAINT \`FK_Post_user\`
FOREIGN KEY (\`userId\`) REFERENCES \`TestDb\`.\`User\` (\`id\`)
  `,
  mssql: tsql`
ALTER TABLE [TestDb].[TestSchema].[Post] ADD CONSTRAINT [FK_Post_user]
FOREIGN KEY ([userId]) REFERENCES [TestDb].[TestSchema].[User] ([id]);
CREATE INDEX [IDX_Post_Post_user] ON [TestDb].[TestSchema].[Post] ([userId]);
  `,
  postgresql: pgsql`
ALTER TABLE "TestSchema"."Post" ADD CONSTRAINT "FK_Post_user"
FOREIGN KEY ("userId") REFERENCES "TestSchema"."User" ("id");
CREATE INDEX "IDX_Post_Post_user" ON "TestSchema"."Post" ("userId");
  `,
};

export const dropFk: ExpectedSql = {
  mysql: mysql`ALTER TABLE \`TestDb\`.\`Post\` DROP FOREIGN KEY \`FK_Post_user\``,
  mssql: tsql`ALTER TABLE [TestDb].[TestSchema].[Post] DROP CONSTRAINT [FK_Post_user]`,
  postgresql: pgsql`ALTER TABLE "TestSchema"."Post" DROP CONSTRAINT "FK_Post_user"`,
};

export const addIdx: ExpectedSql = {
  mysql: mysql`CREATE UNIQUE INDEX \`IDX_User_email\` ON \`TestDb\`.\`User\` (\`email\` ASC)`,
  mssql: tsql`CREATE UNIQUE INDEX [IDX_User_email] ON [TestDb].[TestSchema].[User] ([email] ASC)`,
  postgresql: pgsql`CREATE UNIQUE INDEX "IDX_User_email" ON "TestSchema"."User" ("email" ASC)`,
};

export const dropIdx: ExpectedSql = {
  mysql: mysql`DROP INDEX \`IDX_User_email\` ON \`TestDb\`.\`User\``,
  mssql: tsql`DROP INDEX [IDX_User_email] ON [TestDb].[TestSchema].[User]`,
  postgresql: pgsql`DROP INDEX "TestSchema"."IDX_User_email"`,
};

export const dropIdxComposite: ExpectedSql = {
  mysql: mysql`DROP INDEX \`IDX_User_name_email\` ON \`TestDb\`.\`User\``,
  mssql: tsql`DROP INDEX [IDX_User_name_email] ON [TestDb].[TestSchema].[User]`,
  postgresql: pgsql`DROP INDEX "TestSchema"."IDX_User_name_email"`,
};

//#endregion

//#region ========== View ==========

export const createView: ExpectedSql = {
  mysql: mysql`
CREATE OR REPLACE VIEW \`TestDb\`.\`ActiveUsers\` AS
SELECT * FROM \`TestDb\`.\`User\` AS \`T1\`
WHERE \`T1\`.\`isActive\` <=> TRUE
  `,
  mssql: tsql`
CREATE OR ALTER VIEW [TestDb].[TestSchema].[ActiveUsers] AS
SELECT * FROM [TestDb].[TestSchema].[User] AS [T1]
WHERE (([T1].[isActive] IS NULL AND 1 IS NULL) OR [T1].[isActive] = 1)
  `,
  postgresql: pgsql`
CREATE OR REPLACE VIEW "TestSchema"."ActiveUsers" AS
SELECT * FROM "TestSchema"."User" AS "T1"
WHERE "T1"."isActive" IS NOT DISTINCT FROM TRUE
  `,
};

export const dropView: ExpectedSql = {
  mysql: mysql`DROP VIEW IF EXISTS \`TestDb\`.\`ActiveUsers\``,
  mssql: tsql`DROP VIEW IF EXISTS [TestDb].[TestSchema].[ActiveUsers]`,
  postgresql: pgsql`DROP VIEW IF EXISTS "TestSchema"."ActiveUsers"`,
};

//#endregion

//#region ========== Procedure ==========

export const createProc: ExpectedSql = {
  mysql: mysql`
CREATE PROCEDURE \`TestDb\`.\`GetUserById\`(IN \`userId\` BIGINT)
BEGIN
-- DBMSwrite matching query --;
END
  `,
  mssql: tsql`
CREATE OR ALTER PROCEDURE [TestDb].[TestSchema].[GetUserById] @userId BIGINT
AS
BEGIN
SET NOCOUNT ON;
-- DBMSwrite matching query --
END
  `,
  postgresql: pgsql`
CREATE OR REPLACE FUNCTION "TestSchema"."GetUserById"("userId" BIGINT)
RETURNS TABLE("id" BIGINT, "name" VARCHAR(100), "email" VARCHAR(200)) AS $$
BEGIN
-- DBMSwrite matching query --;
END;
$$ LANGUAGE plpgsql
  `,
};

export const dropProc: ExpectedSql = {
  mysql: mysql`DROP PROCEDURE IF EXISTS \`TestDb\`.\`GetUserById\``,
  mssql: tsql`DROP PROCEDURE IF EXISTS [TestDb].[TestSchema].[GetUserById]`,
  postgresql: pgsql`DROP FUNCTION IF EXISTS "TestSchema"."GetUserById"()`,
};

//#endregion
